# Story S-1.3: Setup Supabase Project and Initial Schema

## User Story

**As a** Backend Developer,
**I want to** establish a foundational Supabase project with a defined initial database schema, configured authentication, and access policies,
**So that I can** provide a secure and scalable data storage and authentication layer for the application, enabling further backend and frontend development.

## Development Specification

### 1. Overview and Motivation

The project requires a robust, scalable, and secure backend solution for data storage, real-time capabilities, authentication, and API management. Supabase is chosen as the primary Backend-as-a-Service (BaaS) for its combination of a PostgreSQL database, built-in authentication, real-time subscriptions, and auto-generated APIs (REST and GraphQL). This allows for rapid development, reduces operational overhead, and provides a managed solution for core backend functionalities, aligning with the project's goal of delivering an MVP efficiently. This story is a foundational task, enabling subsequent feature development involving user interaction, data persistence, and reporting.

### 2. Initial Functionality and Core Data Models

Supabase must initially support the core functionalities required for the MVP:
*   **User Authentication:** Secure sign-up, sign-in, and session management for various user roles (e.g., Managers, Employees).
*   **Data Storage for KPIs:** Persistent storage for key performance indicators (KPIs) data, enabling tracking and visualization.
*   **Data Storage for Shift Reports:** Storage for detailed shift report data, including employee information, tasks completed, and any incidents.
*   **Basic User Profile Management:** Storage of essential user metadata linked to authentication (e.g., user roles, names).
*   **API Access:** Provide secure API endpoints for the frontend and (if applicable) backend services to interact with the stored data.

The initial PostgreSQL schema will leverage Supabase's built-in `auth.users` table for core user management. A separate `public.profiles` table will extend this, linking directly via a foreign key (`id` from `auth.users` to `profile_id` in `public.profiles`) to store application-specific user metadata (`role`, `name`, `department_id`, etc.). Core data models will include `public.shift_reports` (linked to `public.profiles`), `public.kpis` (potentially linked to `shift_reports` or `employees`), and supporting tables for `departments` and `employees`.

### 3. Architectural Considerations

*   **Monorepo Structure:** Supabase will support both the Next.js frontend and NestJS backend API. The NestJS backend will serve as an intermediary for complex business logic and validation, while direct frontend-to-Supabase interaction will be used for simpler data access.
*   **Security First:** Robust Row-Level Security (RLS) policies are paramount to ensure authorized data access for users and roles.
*   **Scalability:** The initial schema design must consider future growth, incorporating proper indexing and normalization.
*   **Environment Management:** Supabase API keys and URLs require secure management via environment variables for development, staging, and production.
*   **Migration Strategy:** A clear process for database migrations is essential to manage schema evolution effectively.

### 4. Technical Requirements

*   Supabase project must be configured with a PostgreSQL database.
*   Secure handling of Supabase API keys and URL as environment variables.
*   Support for email/password authentication is mandatory; additional social providers are optional but recommended.
*   Initial schema must include `users`, `profiles`, `shifts`, `kpis`, `employees`, and `departments` tables.
*   All tables must have defined primary and foreign keys, data types, and appropriate constraints (`NOT NULL`, `UNIQUE`).
*   Row-Level Security (RLS) must be enabled and configured for all user-facing tables.
*   RLS policies must enforce read/write access based on user roles and ownership.
*   A mechanism for database migrations (e.g., Supabase CLI or custom scripts) must be established.

### 5. Step-by-step Tasks

1.  **Supabase Project Initialization:**
    *   Create a new Supabase project via the Supabase dashboard (https://supabase.com/).
    *   Retrieve the project's unique identifier and connection string.
    *   (Optional but Recommended) Rename the default `public` schema to a more domain-specific name (e.g., `app_data`) for clarity and separation.
    *   Configure project settings including region and budget limits.

2.  **Environment Variable Setup:**
    *   From the Supabase project settings, retrieve the `SUPABASE_URL` and `SUPABASE_ANON_KEY`.
    *   Add these values to `.env.local` file in the project root for local development.
    *   Document the process for securely integrating these environment variables into CI/CD pipelines (e.g., GitHub Actions secrets, Vercel environment variables).

3.  **Authentication Configuration:**
    *   Navigate to the "Authentication" section in the Supabase dashboard.
    *   Enable "Email" provider and configure its settings (e.g., email confirmation, password reset templates).
    *   (Optional) Integrate and configure at least one social login provider (e.g., Google, GitHub) if deemed necessary for initial user experience.
    *   Customize default email templates for welcome, password reset, and magic link as needed.

4.  **Initial PostgreSQL Schema Design & Implementation:**
    *   **Users Table:** Leverage Supabase's `auth.users` table for core user information.
    *   **Profiles Table:** Create a `public.profiles` table with columns:
        *   `id` UUID (Primary Key, Foreign Key to `auth.users.id`)
        *   `created_at` TIMESTAMP WITH TIME ZONE (DEFAULT now())
        *   `updated_at` TIMESTAMP WITH TIME ZONE (DEFAULT now())
        *   `full_name` TEXT
        *   `avatar_url` TEXT
        *   `role` TEXT (e.g., 'manager', 'employee', 'admin', DEFAULT 'employee')
        *   `department_id` UUID (Foreign Key to `public.departments.id`)
    *   **Departments Table:** Create a `public.departments` table with `id` UUID (PK), `name` TEXT (UNIQUE), `created_at`.
    *   **Employees Table:** If distinct from `profiles`, create `public.employees` with `id` UUID (PK), `profile_id` UUID (FK to `public.profiles.id`), `employee_id_number` TEXT (UNIQUE), `hire_date` DATE.
    *   **Shift Reports Table:** Create `public.shift_reports` with `id` UUID (PK), `employee_id` UUID (FK to `public.employees.id` or `public.profiles.id`), `start_time` TIMESTAMP WITH TIME ZONE, `end_time` TIMESTAMP WITH TIME ZONE, `notes` TEXT, `created_at`.
    *   **KPIs Table:** Create `public.kpis` with `id` UUID (PK), `metric_name` TEXT, `value` NUMERIC, `recorded_at` TIMESTAMP WITH TIME ZONE, `shift_report_id` UUID (FK to `public.shift_reports.id`, nullable).
    *   Generate SQL scripts for the creation of all custom tables and foreign key constraints.
    *   Apply these SQL scripts to the Supabase database using the SQL Editor or migration tool.

5.  **Role-Based Access Policies (RLS):**
    *   For each custom user-facing table (`profiles`, `departments`, `employees`, `shift_reports`, `kpis`):
        *   Enable Row-Level Security.
        *   Define `SELECT` policies (e.g., users can only view their own profile/data, managers can view all data for their department).
        *   Define `INSERT`, `UPDATE`, `DELETE` policies based on roles and ownership.
    *   Test RLS policies thoroughly to ensure no unauthorized data access or modification is possible.

6.  **Database Migrations Setup:**
    *   Install and initialize the Supabase CLI in the project root or backend directory (`pnpm install supabase --save-dev` then `supabase init`).
    *   Link the local Supabase project to the remote project (`supabase link --project-id <project-id>`).
    *   Generate the first migration script reflecting the initial schema (`supabase migration new initial_schema`).
    *   Apply the migration to the local development database (`supabase db reset` or `supabase db push`).
    *   Document the workflow for creating new migrations, applying them, and handling rollbacks.

### 6. Deliverables

*   **Supabase Project:** A newly created and configured Supabase project instance.
*   **Environment Variables:** Supabase API keys and URL securely configured in `.env.local` and documented for CI/CD.
*   **Authentication Providers:** Supabase authentication configured with email/password (and optional social providers).
*   **Initial PostgreSQL Schema:** SQL scripts defining all initial application tables and their relationships, applied to Supabase.
*   **Role-Level Security (RLS) Policies:** Implemented RLS policies for critical tables.
*   **Database Migrations Setup:** Initialized Supabase CLI and a generated first migration script.

### 7. Definition of Done

*   All tasks in "Step-by-step Tasks" are completed.
*   All Acceptance Criteria are met and verified.
*   The Supabase project is deployed and accessible.
*   Environment variables are set up locally and documented for production.
*   Initial database schema is applied and validated.
*   RLS policies are configured and tested to prevent unauthorized access.
*   The migration system is operational with an initial migration recorded.
*   All new or modified code (SQL scripts, config) is reviewed and merged.

### 8. Acceptance Criteria

*   **AC1: Supabase Project Accessibility**
    *   **Given** a developer has Supabase credentials,
    *   **When** they attempt to access the newly created Supabase project,
    *   **Then** they can successfully log in and view the project dashboard.

*   **AC2: Environment Variable Configuration**
    *   **Given** the project's environment variables are loaded,
    *   **When** the application attempts to connect to Supabase,
    *   **Then** it successfully establishes a connection using the provided Project URL and Anon Key.

*   **AC3: Authentication Functionality**
    *   **Given** email/password authentication is enabled,
    *   **When** a new user attempts to sign up with a valid email and password,
    *   **Then** the user account is created in Supabase, and they can successfully log in.
    *   **And** (if applicable) a user can successfully sign up/log in using the configured social provider.

*   **AC4: Initial Schema Integrity**
    *   **Given** the initial schema SQL scripts have been executed,
    *   **When** inspecting the Supabase database,
    *   **Then** all defined tables (e.g., `users`, `profiles`, `shifts`, `kpis`, `departments`, `employees`) exist with the correct column names, data types, primary keys, foreign keys, and constraints.

*   **AC5: Role-Level Security Enforcement**
    *   **Given** RLS is enabled for critical tables,
    *   **When** a user attempts to perform a data operation (e.g., `SELECT`, `INSERT`, `UPDATE`, `DELETE`) that violates an RLS policy,
    *   **Then** the operation is denied, and no unauthorized data access or modification occurs.
    *   **And** when a user attempts a data operation that adheres to an RLS policy, the operation succeeds.

*   **AC6: Migration Readiness**
    *   **Given** a change is made to the database schema locally,
    *   **When** the migration generation command is executed,
    *   **Then** a new, correct migration file is created reflecting the schema changes, ready to be applied.

### 9. Dependencies

*   **Backend Application:** The backend application (NestJS) will depend on the Supabase project for data storage and authentication services. Development of backend API routes will require the Supabase schema to be in place.
*   **Frontend Application:** The frontend application will depend on the Supabase project for user authentication and data retrieval.
*   **Infrastructure/Deployment:** Environment variables for Supabase (URL, Anon Key) will need to be configured in the deployment environment (e.g., Vercel, Docker, Kubernetes).
*   **UI/UX Design:** The design of the user authentication flows and any data display components will inform the initial schema design and authentication provider choices.

### 10. Assumptions, Risks, and Constraints

*   **Assumptions:**
    *   Supabase's free tier (or chosen paid plan) will meet initial performance and storage requirements.
    *   Frontend and backend teams have basic familiarity with Supabase client libraries/APIs.
    *   Database schema can be evolved using Supabase migrations.
*   **Risks:**
    *   **Vendor Lock-in:** Relying heavily on Supabase services could make migration to other BaaS or self-hosted solutions challenging later.
    *   **Performance Bottlenecks:** Unoptimized RLS policies or complex queries could lead to performance issues as data grows.
    *   **Security Misconfiguration:** Incorrect RLS policies could lead to data breaches.
    *   **Learning Curve:** Initial learning curve for advanced Supabase features (e.g., custom functions, edge functions).
*   **Constraints:**
    *   **Budget:** Must operate within a defined budget for Supabase services (initially free tier).
    *   **Time:** Rapid setup required for MVP delivery.
    *   **Technology Stack:** Must integrate seamlessly with Next.js (frontend) and NestJS (backend).

### 11. Relevant Documentation Links

*   Supabase Documentation: [https://supabase.com/docs](https://supabase.com/docs)
*   Supabase CLI Documentation: [https://supabase.com/docs/guides/cli](https://supabase.com/docs/guides/cli)
*   PostgreSQL Documentation: [https://www.postgresql.org/docs/](https://www.postgresql.org/docs/)