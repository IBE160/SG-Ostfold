## Contextual Background for Story S-1.3: Set up Supabase Project and Initial Schema

### 1. Why a Supabase Backend is Needed

The project requires a robust, scalable, and secure backend solution for data storage, real-time capabilities, authentication, and API management. Supabase is chosen as the primary backend-as-a-service (BaaS) for its combination of a PostgreSQL database, built-in authentication, real-time subscriptions, and auto-generated APIs (REST and GraphQL). This allows for rapid development, reduces operational overhead, and provides a managed solution for core backend functionalities, aligning with the project's goal of delivering an MVP efficiently.

### 2. Functionality it Must Initially Support

Initially, Supabase must support the core functionalities required for the MVP:
*   **User Authentication:** Secure sign-up, sign-in, and session management for various user roles (e.g., Managers, Employees).
*   **Data Storage for KPIs:** Persistent storage for key performance indicators (KPIs) data, enabling tracking and visualization.
*   **Data Storage for Shift Reports:** Storage for detailed shift report data, including employee information, tasks completed, and any incidents.
*   **Basic User Profile Management:** Storage of essential user metadata linked to authentication (e.g., user roles, names).
*   **API Access:** Provide secure API endpoints for the frontend and (if applicable) backend services to interact with the stored data.

### 3. How the Schema Relates to User Authentication and Core Data Models

The initial PostgreSQL schema will be built around two primary pillars:

*   **User Authentication:** Supabase's built-in `auth.users` table will be leveraged for core user management. A separate `public.profiles` table will extend this, linking directly to `auth.users` via a foreign key (e.g., `id` from `auth.users` to `profile_id` in `public.profiles`). This `profiles` table will store application-specific user metadata like `role`, `name`, `department_id`, etc. Role-based access control will be critical here, managed through Row-Level Security (RLS) policies.

*   **Core Data Models:**
    *   **Shift Reports:** A `public.shift_reports` table will store daily or shift-specific data, linked to `public.profiles` to identify the reporting employee.
    *   **KPIs:** `public.kpis` or similar tables will store calculated KPI values, potentially linked to `shift_reports` or `employees` for contextual reporting.
    *   **Supporting Data:** Tables for `departments`, `employees` (if different from `profiles`), and other lookup data will establish the foundational relational structure.

### 4. Architectural Considerations

*   **Monorepo Structure:** The Supabase setup will primarily support the Next.js frontend and the NestJS backend API. The NestJS backend will act as an intermediary layer for complex business logic, data validation, and potentially orchestrating interactions with Supabase (though direct frontend-to-Supabase interaction will also be explored for simpler data access).
*   **Security First:** Emphasis on robust Row-Level Security (RLS) policies to ensure data is accessible only to authorized users/roles.
*   **Scalability:** Initial schema design will consider future growth and performance, ensuring proper indexing and normalization.
*   **Environment Management:** Supabase configuration (API keys, URLs) must be managed securely via environment variables, adhering to different environments (development, staging, production).
*   **Migration Strategy:** A clear process for database migrations is essential to manage schema evolution.

### 5. References to Higher-Level Epics or System Goals

This story (S-1.3) directly contributes to:
*   **Epic 1: User & Authentication Management:** Provides the fundamental authentication mechanism and user data storage.
*   **Epic 2: Shift Reporting & Data Capture:** Establishes the database foundation for storing shift-related data.
*   **Epic 3: KPI Dashboard & Visualization:** Creates the necessary data models to capture and retrieve KPI information for dashboard display.
*   **Overall Goal:** Accelerate backend development by leveraging a managed BaaS, allowing the team to focus on core business logic.

### 6. Assumptions, Risks, and Constraints

*   **Assumptions:**
    *   Supabase's free tier (or chosen paid plan) will meet initial performance and storage requirements.
    *   Frontend and backend teams have basic familiarity with Supabase client libraries/APIs.
    *   Database schema can be evolved using Supabase migrations.
*   **Risks:**
    *   **Vendor Lock-in:** Relying heavily on Supabase services could make migration to other BaaS or self-hosted solutions challenging later.
    *   **Performance Bottlenecks:** Unoptimized RLS policies or complex queries could lead to performance issues as data grows.
    *   **Security Misconfiguration:** Incorrect RLS policies could lead to data breaches.
    *   **Learning Curve:** Initial learning curve for advanced Supabase features (e.g., custom functions, edge functions).
*   **Constraints:**
    *   **Budget:** Must operate within a defined budget for Supabase services (initially free tier).
    *   **Time:** Rapid setup required for MVP delivery.
    *   **Technology Stack:** Must integrate seamlessly with Next.js (frontend) and NestJS (backend).

### 7. How this Story Fits into the Overall Development Sequence

This story is a foundational task and one of the earliest backend development stories. It is a critical enabler for most subsequent feature development, especially those involving user interaction, data persistence, and reporting. It should be completed early in the development cycle to provide a stable data and authentication layer for both frontend and backend teams to build upon.
